#include <dev_util.h>
#include <dev_globals.h>
#include <bootrom_func.h>
#include <dev/addr.h>
#include <util/armv8.h>

GLOBAL_LONG(rom_base, 0x100000000)
GLOBAL_LONG(rom_size, 0x2000000)

PAYLOAD_SECTION
void *search_for_index()
{
    uint32_t *addr;
    for(addr = (uint32_t *) GET_GLOBAL(rom_base);
        addr < (uint32_t *) (GET_GLOBAL(rom_base) + GET_GLOBAL(rom_size));
        addr++)
    {
        // calculates next boot index to try
        if(*addr == 0x13000013) // sbfx w19, w0, 0x0, 0x1
            return addr;
    }

    return 0;
}

PAYLOAD_SECTION
__attribute__ ((noreturn))
void setup()
{
    void *this_payload;

    // this function returns the address of the boot trampoline. we
    // patch it to return NULL so that the boot will instead proceed
    // back to this function.
    uint32_t *return_boot_trampoline = (uint32_t *) (WRITEABLE_ROM(0x10000839c));
    __asm__ volatile ("adr %0, _start" : "=r" (this_payload));

    return_boot_trampoline[0] = movz(X0, (uint16_t) ((uint64_t) this_payload & 0xFFFF), 0);
    return_boot_trampoline[1] = MOVK(X0, 0, 0);

    void (*boot_index)() = search_for_index();

    __asm__ volatile ("mov x8, %0" :: "r" (boot_index));
    __asm__ volatile ("mov x22, 0x0");
    __asm__ volatile ("mov x24, 0x0");
    __asm__ volatile ("mov x0, 0x0");
    __asm__ volatile ("br x8");

    // should never get here
    while(1);
}

PAYLOAD_SECTION
uint32_t *match(uint32_t *addr, uint32_t target, uint32_t mask, int len)
{
    while(len != 0)
    {
        if((*addr & mask) == target)
            return addr;

        addr++;
        len -= 4;
    }

    return 0;
}

PAYLOAD_SECTION
uint32_t *match_backwards(uint32_t *addr, uint32_t target, uint32_t mask, int len)
{
    while(len != 0)
    {
        if((*addr & mask) == target)
            return addr;

        addr--;
        len -= 4;
    }

    return 0;
}

PAYLOAD_SECTION
void patch()
{
    // todo: check iBoot string
}


void _start()
{
    setup();
}