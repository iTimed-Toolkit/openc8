#include "dev_globals.h"
#include "dev_util.h"
#include "bootrom_func.h"

#define NUM_HANDLERS    32
#define NUM_ADDRESSES   128

GLOBAL_STR(inst_handler_str, "inst_handler")

GLOBAL_STR(inst_data_str, "inst_data")

GLOBAL_PTR(addr_dfu_img_base, ADDR_DFU_IMG_BASE);
GLOBAL_PTR(addr_dfu_intf_handle, ADDR_DFU_INTF_HANDLE);
GLOBAL_PTR(addr_handle_intf_req, ADDR_HANDLE_INTF_REQ);

GLOBAL_CHAR(initialized, 0)

GLOBAL_PTR(installed_handlers, 0)

GLOBAL_INT(num_handlers, 1) // 0xFFFF is reserved for teardown

// assumption - 8 byte addresses
GLOBAL_PTR(installed_data, 0);
GLOBAL_INT(num_data, 0)

PAYLOAD_SECTION
void *install_handler(void *arg)
{
    struct install_info *info = (struct install_info *) arg;
    struct install_info *handlers = GET_GLOBAL(installed_handlers);
    void *addr = 0, *src;

    if(GET_GLOBAL(num_handlers) == NUM_HANDLERS)
        return 0;

    dev_memcpy(&handlers[GET_GLOBAL(num_handlers)].name,
               &info->name, INSTALL_NAME_SZ);

    if(info->len > 0)
    {
        addr = dev_malloc(info->len);
        src = GET_GLOBAL(addr_dfu_img_base) + sizeof(struct install_info);
        dev_memcpy(addr, src, info->len);

        handlers[GET_GLOBAL(num_handlers)].len = info->len;
        handlers[GET_GLOBAL(num_handlers)].handler = addr;
    }
    else
    {
        handlers[GET_GLOBAL(num_handlers)].len = -1;
        handlers[GET_GLOBAL(num_handlers)].handler = info->handler;
    }

    SET_GLOBAL(num_handlers, GET_GLOBAL(num_handlers) + 1);
    return addr;
}

PAYLOAD_SECTION
void *install_data(void *arg)
{
    struct install_info *info = (struct install_info *) arg;
    void **installed_pointers = GET_PTR_TO_GLOBAL(installed_data);
    void *res;

    if(GET_GLOBAL(num_data) == NUM_ADDRESSES)
        return 0;

    res = dev_malloc(info->len);
    installed_pointers[GET_GLOBAL(num_data)] = res;

    SET_GLOBAL(num_data, GET_GLOBAL(num_data) + 1);
    return res;
}

PAYLOAD_SECTION
int handle_intf_req_wrap(struct usb_request *req, void **out)
{
    return handle_intf_req(req, out);
}

PAYLOAD_SECTION
void install(char *name, void *(*handler)(void *))
{
    struct install_info info = {
            .name = {0},
            .len = 0,
            .handler = 0
    };

    dev_memcpy(&info.name, name, dev_strlen(name));
    info.len = 0;
    info.handler = handler;

    install_handler(&info);
}

//static inline void teardown()
//{
//    int i;
//    void **installed_pointers = GET_PTR_TO_GLOBAL(installed_data), *self;
//    struct install_info *info = GET_GLOBAL(installed_handlers);
//
//    for(i = 0; i < GET_GLOBAL(num_data); i++)
//        dev_free(installed_pointers[i]);
//
//    for(i = 0; i < GET_GLOBAL(num_handlers); i++)
//    {
//        if(info[i].len != -1)
//            dev_free(info[i].handler);
//    }
//
//    dev_free(info);
//
//    // reset the USB handler
//    *((void **) GET_GLOBAL(addr_dfu_intf_handle)) = GET_GLOBAL(addr_handle_intf_req);
//
//    // free ourselves!
//    __asm__ volatile ("adr %0, _start" : "=r" (self));
//    dev_free(self);
//}

static inline struct install_info *initialize()
{
    struct install_info *handlers;
    void *p_inst_handler, *p_inst_data;

    handlers = dev_malloc(NUM_HANDLERS * sizeof(struct install_info));
    SET_GLOBAL(installed_handlers, handlers);

    __asm__ volatile ("adr %0, install_handler" : "=r" (p_inst_handler));
    install(GET_PTR_TO_GLOBAL(inst_handler_str), p_inst_handler);

    __asm__ volatile ("adr %0, install_data" : "=r" (p_inst_data));
    install(GET_PTR_TO_GLOBAL(inst_data_str), p_inst_data);

    return handlers;
}

PAYLOAD_SECTION
void handle(struct usb_request *req)
{
    int h = 0xFFFF - req->wValue;
    struct install_info *handlers;

    if(GET_GLOBAL(initialized) == 0)
        handlers = initialize();
    else
        handlers = GET_GLOBAL(installed_handlers);

    if(h < GET_GLOBAL(num_handlers))
        handlers[h].handler(GET_GLOBAL(addr_dfu_img_base));

    usb_core_do_io(0x80, GET_GLOBAL(addr_dfu_img_base), req->wLength, 0);
}