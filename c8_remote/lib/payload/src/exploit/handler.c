#include "dev_globals.h"
#include "dev_util.h"
#include "bootrom_func.h"

GLOBAL_PTR(addr_dfu_img_base, ADDR_DFU_IMG_BASE);
GLOBAL_PTR(addr_dfu_intf_handle, ADDR_DFU_INTF_HANDLE);
GLOBAL_PTR(addr_handle_intf_req, ADDR_HANDLE_INTF_REQ);

GLOBAL_CHAR(initialized, 0)
GLOBAL_PTR(installed_gadgets, 0)
GLOBAL_INT(num_gadgets, 0)

PAYLOAD_SECTION
void install_gadget()
{
    struct install_args *info = GET_GLOBAL(addr_dfu_img_base);
    struct cmd_resp *resp = GET_GLOBAL(addr_dfu_img_base);
    struct install_args *gadgets = GET_GLOBAL(installed_gadgets);
    void *addr, *src;

    if(GET_GLOBAL(num_gadgets) == NUM_GADGETS)
    {
        resp->status = CMD_FAIL_FULL;
        return;
    }

    if(info->len > 0)
    {
        addr = dev_malloc(info->len);
        src = GET_GLOBAL(addr_dfu_img_base) + sizeof(struct install_args);

        dev_memcpy(addr, src, info->len);

        gadgets[GET_GLOBAL(num_gadgets)].type = info->type;
        gadgets[GET_GLOBAL(num_gadgets)].len = info->len;
        gadgets[GET_GLOBAL(num_gadgets)].addr = EXECUTABLE_SRAM((uint64_t) addr);
    }
    else
    {
        addr = (void *) info->addr;

        gadgets[GET_GLOBAL(num_gadgets)].type = -1; // PAYLOAD_BUILTIN
        gadgets[GET_GLOBAL(num_gadgets)].len = -1;
        gadgets[GET_GLOBAL(num_gadgets)].addr = (uint64_t) addr;
    }

    if(GET_GLOBAL(initialized))
    {
        resp->status = CMD_SUCCESS;
        resp->args[0] = GET_GLOBAL(num_gadgets);
        resp->args[1] = (uint64_t) addr;
    }

    SET_GLOBAL(num_gadgets, GET_GLOBAL(num_gadgets) + 1);
}

PAYLOAD_SECTION
void status_gadget()
{
    struct cmd_resp *resp = GET_GLOBAL(addr_dfu_img_base);
    struct install_args *gadgets = GET_GLOBAL(installed_gadgets);
    int num = GET_GLOBAL(num_gadgets);

    dev_memcpy(GET_GLOBAL(addr_dfu_img_base) + sizeof(struct cmd_resp),
               gadgets, num * sizeof(struct install_args));

    resp->status = CMD_SUCCESS;
    resp->args[0] = num;
}

PAYLOAD_SECTION
void install(int type, void *handler)
{
    struct install_args backup, info = {
            .type = type,
            .len = 0,
            .addr = (uint64_t) handler
    };

    // todo: this is an ugly fix
    dev_memcpy(&backup, GET_GLOBAL(addr_dfu_img_base),
               sizeof(struct install_args));

    dev_memcpy(GET_GLOBAL(addr_dfu_img_base),
               &info, sizeof(struct install_args));

    install_gadget();

    dev_memcpy(GET_GLOBAL(addr_dfu_img_base),
               &backup, sizeof(struct install_args));
}

static inline struct install_args *initialize()
{
    struct install_args *gadgets;
    void *p_stat_gadget, *p_inst_gadget;

    gadgets = dev_malloc(NUM_GADGETS * sizeof(struct install_args));
    SET_GLOBAL(installed_gadgets, gadgets);

    // always install the status gadget first
    __asm__ volatile ("adr %0, status_gadget" : "=r" (p_stat_gadget));
    install(-1, p_stat_gadget); // -1 = PAYLOAD_BUILTIN

    // then install the installation gadget
    __asm__ volatile ("adr %0, install_gadget" : "=r" (p_inst_gadget));
    install(-1, p_inst_gadget); // -1 = PAYLOAD_BUILTIN

    SET_GLOBAL(initialized, 1);
    return gadgets;
}

PAYLOAD_SECTION
void handle(struct usb_request *req)
{
    int h = 0xFFFF - req->wValue;
    struct install_args *gadgets;

    if(GET_GLOBAL(initialized) == 0)
        gadgets = initialize();
    else
        gadgets = GET_GLOBAL(installed_gadgets);

    if(h < GET_GLOBAL(num_gadgets))
        ((void (*)()) gadgets[h].addr)();

    usb_core_do_io(0x80, GET_GLOBAL(addr_dfu_img_base), req->wLength, 0);
}