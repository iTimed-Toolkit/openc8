#include "dev_globals.h"
#include "dev_util.h"
#include "bootrom_func.h"

GLOBAL_PTR(addr_dfu_img_base, ADDR_DFU_IMG_BASE);
GLOBAL_PTR(addr_dfu_intf_handle, ADDR_DFU_INTF_HANDLE);
GLOBAL_PTR(addr_handle_intf_req, ADDR_HANDLE_INTF_REQ);

GLOBAL_CHAR(initialized, 0)
GLOBAL_PTR(installed_gadgets, 0)

PAYLOAD_SECTION
void install_gadget()
{
    int i;
    struct install_args *info = GET_GLOBAL(addr_dfu_img_base);
    struct cmd_resp *resp = GET_GLOBAL(addr_dfu_img_base);
    struct install_args *gadgets = GET_GLOBAL(installed_gadgets), *slot = 0;
    void *addr, *src;

    for(i = 0; i < NUM_GADGETS; i++)
    {
        if(gadgets[i].type == -1 &&
           gadgets[i].len == -1 &&
           gadgets[i].addr == -1)
        {
            slot = &gadgets[i];
            break;
        }
    }

    if(slot == 0)
    {
        resp->status = CMD_FAIL_FULL;
        return;
    }

    if(info->len > 0)
    {
        addr = dev_malloc(info->len);
        src = GET_GLOBAL(addr_dfu_img_base) + sizeof(struct install_args);

        dev_memcpy(addr, src, info->len);

        slot->type = info->type;
        slot->len = info->len;
        slot->addr = EXECUTABLE_SRAM((uint64_t) addr);

        // code can stick around in instruction cache, so invalidate it
        __asm__ volatile ("dmb sy");
        __asm__ volatile ("ic iallu");
        __asm__ volatile ("dsb sy");
        __asm__ volatile ("isb");
    }
    else
    {
        addr = (void *) info->addr;

        slot->type = -1; // PAYLOAD_BUILTIN
        slot->len = -1;
        slot->addr = (uint64_t) addr;
    }

    if(GET_GLOBAL(initialized))
    {
        resp->status = CMD_SUCCESS;
        resp->args[0] = i;
        resp->args[1] = (uint64_t) addr;
    }
}

PAYLOAD_SECTION
void uninstall_gadget()
{
    int i;
    struct install_args *info = GET_GLOBAL(addr_dfu_img_base);
    struct cmd_resp *resp = GET_GLOBAL(addr_dfu_img_base);
    struct install_args *gadgets = GET_GLOBAL(installed_gadgets);

    for(i = 0; i < NUM_GADGETS; i++)
    {
        if(gadgets[i].type == info->type &&
           gadgets[i].len == info->len &&
           gadgets[i].addr == info->addr)
        {
            if(info->type != -1 && info->len != -1)
            {
                dev_memset((void *) WRITEABLE_SRAM(gadgets[i].addr), 0, info->len);
                dev_free((void *) WRITEABLE_SRAM(gadgets[i].addr));

                gadgets[i].type = -1;
                gadgets[i].len = -1;
            }

            gadgets[i].addr = -1;

            // code can stick around in instruction cache, so invalidate it
            __asm__ volatile ("dmb sy");
            __asm__ volatile ("ic iallu");
            __asm__ volatile ("dsb sy");
            __asm__ volatile ("isb");

            resp->status = CMD_SUCCESS;
            resp->args[0] = i;
            resp->args[1] = 0;
            return;
        }
    }

    resp->status = CMD_FAIL_NOTFOUND;
    resp->args[0] = -1;
    resp->args[1] = -1;
}

PAYLOAD_SECTION
void status_gadget()
{
    struct cmd_resp *resp = GET_GLOBAL(addr_dfu_img_base);
    struct install_args *gadgets = GET_GLOBAL(installed_gadgets);

    dev_memcpy(GET_GLOBAL(addr_dfu_img_base) + sizeof(struct cmd_resp),
               gadgets, NUM_GADGETS * sizeof(struct install_args));

    resp->status = CMD_SUCCESS;
    resp->args[0] = NUM_GADGETS;
}

PAYLOAD_SECTION
void install(int type, void *handler)
{
    struct install_args backup, info = {
            .type = type,
            .len = 0,
            .addr = (uint64_t) handler
    };

    // todo: this is an ugly fix
    dev_memcpy(&backup, GET_GLOBAL(addr_dfu_img_base),
               sizeof(struct install_args));

    dev_memcpy(GET_GLOBAL(addr_dfu_img_base),
               &info, sizeof(struct install_args));

    install_gadget();

    dev_memcpy(GET_GLOBAL(addr_dfu_img_base),
               &backup, sizeof(struct install_args));
}

static inline struct install_args *initialize()
{
    int i;
    struct install_args *gadgets;
    void *p_stat_gadget, *p_inst_gadget, *p_uninst_gadget;

    gadgets = dev_malloc(NUM_GADGETS * sizeof(struct install_args));
    SET_GLOBAL(installed_gadgets, gadgets);

    for(i = 0; i < NUM_GADGETS; i++)
    {
        gadgets[i].type = -1;
        gadgets[i].len = -1;
        gadgets[i].addr = -1;
    }

    // always install the status gadget first
    __asm__ volatile ("adr %0, status_gadget" : "=r" (p_stat_gadget));
    install(-1, p_stat_gadget); // -1 = PAYLOAD_BUILTIN

    // then install the installation gadget
    __asm__ volatile ("adr %0, install_gadget" : "=r" (p_inst_gadget));
    install(-1, p_inst_gadget); // -1 = PAYLOAD_BUILTIN

    // then finally the uninstallation gadget
    __asm__ volatile ("adr %0, uninstall_gadget" : "=r" (p_uninst_gadget));
    install(-1, p_uninst_gadget); // -1 = PAYLOAD_BUILTIN

    SET_GLOBAL(initialized, 1);
    return gadgets;
}

#ifdef DEBUG_PAYLOADS
GLOBAL_PTR(demote_reg, ADDR_DEMOTE_REG)
GLOBAL_CHAR(debug_initialized, 0);
#endif

PAYLOAD_SECTION
void handle(struct usb_request *req)
{
    int h = 0xFFFF - req->wValue;
    struct install_args *gadgets;

    if(GET_GLOBAL(initialized) == 0)
        gadgets = initialize();
    else
        gadgets = GET_GLOBAL(installed_gadgets);

    if(gadgets[h].addr != -1)
    {
#ifdef DEBUG_PAYLOADS
        if(GET_GLOBAL(debug_initialized) == 0)
        {
            uint32_t *reg = GET_GLOBAL(demote_reg);
            *reg = (*reg) & 0xFFFFFFFE;
            SET_GLOBAL(debug_initialized, 1);
        }

        __asm__ volatile ("b 0");
#endif
        ((void (*)()) gadgets[h].addr)();
    }

    usb_core_do_io(0x80, GET_GLOBAL(addr_dfu_img_base), req->wLength, 0);
}